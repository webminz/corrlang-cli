syntax = "proto2";

import "ccp.proto";

option java_package = "io.corrlang.protocol";
option optimize_for = SPEED;

/**
 * This is the service offered by the CorrLang engine.
 * It can both be used by TechSpace plugins (to register themselves)
 * or language clients (language server etc.) to interact with CorrLang.
 */
service CoreService {

  // General meta-information about the core-service process and health-check.
  rpc GetStatus(GetStatusRequest) returns (CorrLangServiceStatus);

  // Must be called by a TechSpace plugin to be registered as TechSpace.
  rpc RegisterTechSpace (RegisterTechSpaceRequest) returns (TechSpaceRegistered);

  // Instruct CorrLang to parse a _corr-spec_ file and merge it into the context.
  rpc MergeCorrSpec(MergeCorrSpecRequest) returns (ccp.Ack);

  // Lists the registered TechSpace plugins.
  rpc GetRegisteredTechSpaces (GetRegisteredTechSpacesRequest) returns (GetRegisteredTechSpacesResponse);

  // Lists all registered objects, i.e. endpoints, correspondences, views.
  rpc GetObjects (GetObjectsRequest) returns (GetObjectsResponse);

  // Retrieves the formal schema presentation for a given endpoint (identified by id).
  rpc GetSchema (GetSchemaRequest) returns (ccp.Schema);

  // Asks the service to shutdown
  rpc RequestShutdown(ShutdownRequest) returns (ShutdownAcknowledged);

  // Registers a new endpoint within the context.
  rpc RegisterEndpoint (RegisterEndpointRequest) returns (ccp.Endpoint);

  // Adds a schema to a registered endpoint.
  rpc RegisterEndpointSchema (RegisterEndpointSchemaRequest) returns (ccp.Ack);

  // Adds a dataset to a registered endpoint.
  rpc RegisterEndpointDataset(RegisterEndpointDatasetRequest) returns (ccp.Dataset);

  // Adds a service address (URL or socket) to a registered endpoint.
  rpc RegisterEndpointServiceAddress (RegisterEndpointServiceAddressRequest) returns (ccp.Ack);

  // Registers a new correspondence within the context.
  rpc RegisterCorrespondence (RegisterCorrespondenceRequest) returns (ccp.Correspondence);

  // Registers a new view within the context.
  rpc RegisterView (RegisterViewRequest) returns (ccp.View);

  // Asks CorrLang to export the schema of an endpoint to a file using a specified TechSpace.
  rpc WriteSchema (WriteSchemaRequest) returns (ccp.Ack);

  // Asks CorrLang to export the dataset to a file using a specified TechSpace.
  rpc WriteDataset (WriteDatasetRequest) returns (ccp.Ack);

  // Instructs CorrLang to start a proxy for a view on a specified port using a specified TechSpace.
  rpc StartProxy (StartProxyRequest) returns (ccp.Ack);

  // Can be used by SOURCE-endpoints or SERVICE-endpoints that offer a subscribe() method to notify about 'new' data.
  rpc PushData (stream ccp.TreeData) returns (ccp.Ack);

  // Retrieve information about a registered endpoint.
  rpc GetEndpoint (GetEndpointRequest) returns (ccp.Endpoint);

  // Retrieve information about a registered correspondence.
  rpc GetCorrespondence (GetCorrespondenceRequest) returns (ccp.Correspondence);

  // Retrieve information about a registered view.
  rpc GetView (GetViewRequest) returns (ccp.View);

  rpc DeregisterObject (DeregisterObjectRequest) returns (ccp.Ack);

}

// Asks for for the current status of the core service.
message GetStatusRequest {
  // no op request
}

// General information about the CorrLang core-service
message CorrLangServiceStatus {
  // Retrieves the semantic API version of the core-service.
  required int32 apiVersion = 1;
  // The UNIX epoch (second) describing the timestamp when the service was started.
  optional fixed64 startupTS = 2;
  // The id of the core-service process.
  optional fixed64 pid = 3;
}

message GetRegisteredTechSpacesResponse {
  // list of tech space metadata.
  repeated ccp.TechSpaceDescription techSpaces = 1;
}

message GetRegisteredEndpointsResponse {
  // list of endpoints
  repeated ccp.Endpoint endpoints = 1;
}

message GetSchemaRequest {
  required int32 endpointId = 1;
}

message GetRegisteredEndpointsRequest {
}


message GetRegisteredTechSpacesRequest {
}

/**
  * A TechSpace plugin sends this request to inform
  * the CorrLang core service about it's existence.
 */
message RegisterTechSpaceRequest {
  // A unique name for the TechSpace
  required string techSpaceName = 1;
  // The network host where the TechSpace plugin is running (e.g. localhost).
  required string hostname = 2;
  // The port on which the TechSpace plugin is listening.
  required int32 runningOnPort = 3;
  // If the plugin is located on the local machine it may inform about the location of it's binary.
  optional string localFileSystemLocation = 4;
  // Each TechSpace must inform about it's capabilities.
  repeated ccp.TechSpaceCapability capabilities = 6;
  // Some short human-readable description of the TechSpace.
  optional string documentation = 7;
  // Some information about the developer of the plugin and how to reach them.
  optional string developer = 8;
}


// Success message for a TechSpace registration request.
message TechSpaceRegistered {

  // A file system path that CorrLang may use to share data, e.g.
  // large files rather then sending them via IPC (buffers are limited to 2^32).
  optional string systemServiceDataDir = 1;

  // Provides some global, initially-provided key-value config parameters.
  // The idea is that the user may provide them once in a config file.
  map<string, string> initialConfig = 2;
}

/**
 * Instructs the CorrLang system to start observing the specified
 * endpoint. After the request has been accepted, CorrLang will
 * first identify a TechSpace to analyse the endpoint further.
 * If a capable TechSpace exists, it will invoke that one to parse the
 * schema of the endpoint.
 */
message RegisterEndpointRequest {
  /**
   * The absolute file path for the project directory containing the CorrLang _corr-spec_ file, which defines this endpoint.
   */
  required string project = 1;
  /**
   * The symbolic human-readable name that uniquely identifies the endpoint within the project.
   */
  required string name = 2;

  /**
   * The point of endpoint.
   */
  required ccp.EndpointType type = 3;

}


message RegisterEndpointSchemaRequest {
  /**
   * Unique identifier of the endpoint.
   */
  required int32  endpointId = 1;
  /**
   * Absolute or relative path of a schema file.
   */
  oneof schema {
    string fileLocation = 2;
    string url = 3;
  }
  /**
   * The TechSpace to be used for parsing the schma.
   */
  required string techSpace = 4;
}

message RegisterEndpointDatasetRequest {
  /**
   * Unique identifier of the endpoint.
   */
  required int32  endpointId = 1;

  /**
   * The TechSpace to be used for parsing the data.
   */
  required string techSpace = 2;

  oneof location {
    /**
     * A absolute or relative path (files or directories) containing data, which shall be parsed.
     */
     string fileLocation = 3;
    /**
     * A URL pointing to data, which shall be parsed.
     */
     string url = 4;
  }
}


message ServiceURL {
  /**
   * The URL of the service.
   */
  required string url = 1;
}



message RegisterEndpointServiceAddressRequest {
  /**
   * Unique identifier of the endpoint.
   */
  required int32 endpointId = 1;

  /**
  * The TechSpace to be used for communicating with the servicee.
  */
  required string techSpace = 2;

  /**
   * The service address.
   */
  required ccp.ServiceAddress serviceAddress = 3;
}


message WriteSchemaRequest {
  /**
   * Unique identifier of the endpoint.
   */
  required int32 endpointId = 1;

  /**
   * The absolute file path where to write the schema.
   */
  required string fileLocation = 2;

  /*
   * The TechSpace to be used for writing the schema.
   */
  required string techSpace = 3;
}

message ShutdownRequest {

  required uint32 gracePeriodInS = 1;

  optional string reason = 2;
}

message ShutdownAcknowledged {
  required uint32 guaranteedInS = 1;
}

message RegisterCorrespondenceRequest {
  /**
  * The absolute file path for the project directory containing the CorrLang _corr-spec_ file, which defines this correspondence.
  */
  required string project = 1;
  /**
   * The symbolic human-readable name that uniquely identifies the correspondence within the project.
   */
  required string name = 2;

  /**
   * The id of the endpoints that take part in this correspondence.
   */
  repeated int32 endpoints = 3;
}

message RegisterViewRequest {
  /**
  * The absolute file path for the project directory containing the CorrLang _corr-spec_ file, which defines this view.
  */
  required string project = 1;
  /**
   * The symbolic human-readable name that uniquely identifies the view within the project.
   */
  required string name = 2;

  /**
   * The id of the underlying correspondence object for this view.
   */
  required int32 correspondence = 3;

  /**
   * The endpoint type in which view shall be rendered.
   */
  required ccp.EndpointType type = 4;
}

/**
 * Request to retrieve all currently registered objects from the CorrLang system.
 * Optional filters for object type and/or project path can be applied.
 */
message GetObjectsRequest {
  /**
   * Optional: filter by object type.
   */
  optional ccp.CorrLangObjectType objectType = 1;

  /**
   * Optional: filter by project path.
   */
  optional string project = 2;
}

message GetObjectsResponse {

  repeated ccp.CorrLangObject objects = 1;
}

message WriteDatasetRequest {
  required string filePath = 1;
  required string techSpace = 2;
  required bytes correlationUUID = 3;
}

message StartProxyRequest {
  required int32 viewId = 1;
  required fixed32 port = 2;
  required string techSpace = 3;
}

message MergeCorrSpecRequest {


  /**
   * The absolute file path of the CorrLang _corr-spec_ file to be merged into the project.
   */
  required string corrSpecFilePath = 1;

  /**
   * The absolute file path for the project directory containing the CorrLang _corr-spec_ file, which is to be merged.
   */
  optional string project = 2;
}

message GetEndpointRequest {
  required int32 endpointId = 1;
}

message GetCorrespondenceRequest {
  required int32 correspondenceId = 1;
}

message GetViewRequest {
  required int32 viewId = 1;
}

message DeregisterObjectRequest {
  required int32 objectId = 1;
  optional bool cascade = 2 [default = false];
}